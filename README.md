# BallotWords
 Proof of concept: using the hook length formula to enumerate ballot words.

 Def: A **ballot word** of length _n_ on _k_ letters is a string of length _n_ consisting of the letters 1,...,_k_ such that for each index _i_ in the word and each letter _j_, there are more _j_'s at or before index _i_ than there are (_j_+1)'s. For example, 11123212233 is a valid ballot word, but 112223 is not. 

 It is not a trivial problem to count the number of such words on _k_ letters of length _n_ in general. For the _k_=2 case, there is a particularly nice closed formula. For the higher values of _k_, there are sometimes nice(ish) formulas, often involving the Catalan numbers. One way to count the number of ballot words of at most _k_ letters is to instead count the number of standard Young tableaux of height at most _k_, since these are in bijection with the ballot words on _k_ letters. I will eventually upload a proof of this statement, as well as some other results, to this GitHub repository. There are many OEIS sequences corresponding to various values of _k_. I will eventually list them here; I can not recall them right now, and I do not want to hunt them down at the moment.

 The problem of counting standard Young tableaux is theoretically simplier. In particular, I make use of the Hook Length Formula. For a general _k_ and _n_, this formula is quite messy, with multiple factorials and many nested summations and products. There is some simplification that can be done to bring the number of factorial computations down significantly, and this is the expression that this code uses. Initially, this was not a concern, since the code used to just make a list of all possible _k_-tuples, and then throw out the ones that do not form a valid tableau. This was highly wasteful, but I just wanted something that works. For about _n_,_k_>10 the code really started to slow down. I replaced that highly inefficient code with an iterative function that constructs just the valid tableaux, instead of looking at all possible lists and removing the ones that don't work. This is much quicker.

  However, optimizing this function brought to light exactly when the hook length formula produces numbers that exceed the limits of floating point numbers. Specifically, anything at or above _k_=34 just returns all zeros. This happens because, while the hook length formula always returns an integer, if we don't evaluate the entire expression at once (as is impossible for a computer), the divisons produce _very_ small numbers. These get cancelled out by multiplcation by equally large numbers later, but if the division results in a number small enough to get rounded to 0, it breaks. The smallest number I saw while debugging was 5e-324 (I read somewhere that Python floats are 64-bit), and after the next division, it got rounded to zero. What happens is that the first division divides by, essentially, k!. It then multiplies by a few small numbers (only 1 or 2 numbers, each less than 10). Then divides by something on the order of (k-1)!, then multiplies by a few more small numbers (maybe 3 or 4 this time, all less than 15). Eventually, we are dividing by "small" factorials, and multiplying by many more numbers, so we end up multiplying by something close to (but smaller than) k!, while only dividing by numbers less than ~1000. Mathematically, these perfectly cancel out to give the desired count. In code, however, all of the heavy-hitting divisions happening first causes the float to round to zero before the large multiplications can save it. I suppose I could technically do all the multiplications first, but then we would have the opposite issue: getting too large. The best case would be to weave the two together, but that seems complicated. I may try it at a later time.

Contrary to how I usually code, this project has many code comments that describe each step of the process.

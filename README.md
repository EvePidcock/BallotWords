# BallotWords
 Proof of concept: using the hook length formula to enumerate ballot words.

 Def: A **ballot word** of length _n_ on _k_ letters is a string of length _n_ consisting of the letters 1,...,_k_ such that for each index _i_ in the word and each letter _j_, there are more _j_'s at or before index _i_ than there are (_j_+1)'s. For example, 11123212233 is a valid ballot word, but 112223 is not. 

 It is not a trivial problem to count the number of such words on _k_ letters of length _n_ in general. For the _k_=2 case, there is a particularly nice closed formula. For the higher values of _k_, there are sometimes nice(ish) formulas, often involving the Catalan numbers. One way to count the number of ballot words of at most _k_ letters is to instead count the number of standard Young tableaux of height at most _k_, since these are in bijection with the ballot words on _k_ letters. I will eventually upload a proof of this statement, as well as some other results, to this GitHub repository. There are many OEIS sequences corresponding to various values of _k_. I will eventually list them here; I can not recall them right now, and I do not want to hunt them down at the moment.

 The problem of counting standard Young tableaux is theoretically simplier. In particular, I make use of the Hook Length Formula. For a general _k_ and _n_, this formula is quite messy, with multiple factorials and many nested summations and products. There is some simplification that can be done to bring the number of factorial computations down significantly, and this is the expression that this code uses. The factorials are not the issue, however. The code runs so slowly because, as it is just a proof of concept, I did not spend too much time on the code that generates the tableaux. It just makes a list of all possible _k_-tuples, and then throws out the ones that do not form a valid tableau. This is highly wasteful, but I just wanted something that works. For about _n,k_>10 the code really starts to slow down. 

# BallotWords
 Proof of concept: using the hook length formula to enumerate ballot words.

 Def: A **ballot word** of length _n_ on _k_ letters is a string of length _n_ consisting of the letters 1,...,_k_ such that for each index _i_ in the word and each letter _j_, there are more _j_'s at or before index _i_ than there are (_j_+1)'s. For example, 11123212233 is a valid ballot word, but 112223 is not. 

 It is not a trivial problem to count the number of such words on _k_ letters of length _n_ in general. For the _k_=2 case, there is a particularly nice closed formula. For the higher values of _k_, there are sometimes nice(ish) formulas, often involving the Catalan numbers. One way to count the number of ballot words of at most _k_ letters is to instead count the number of standard Young tableaux of height at most _k_, since these are in bijection with the ballot words on _k_ letters. I will eventually upload a proof of this statement, as well as some other results, to this GitHub repository. There are many OEIS sequences corresponding to various values of _k_. I will eventually list them here; I can not recall them right now, and I do not want to hunt them down at the moment.

 The problem of counting standard Young tableaux is theoretically simplier. In particular, I make use of the Hook Length Formula. For a general _k_ and _n_, this formula is quite messy, with multiple factorials and many nested summations and products. There is some simplification that can be done to bring the number of factorial computations down significantly, and this is the expression that this code originally used. Initially, this was not a concern, since the code used to just make a list of all possible _k_-tuples, and then throw out the ones that do not form a valid tableau. This was highly wasteful, but I just wanted something that works. For about _n_,_k_>10 the code really started to slow down. I replaced that highly inefficient code with an iterative function that constructs just the valid tableaux, instead of looking at all possible lists and removing the ones that don't work. This is much quicker.

  However, optimizing this function brought to light exactly when the hook length formula produced numbers that exceeded the limits of floating point numbers. Specifically, anything at or above _k_=34 just returned all zeros. This happened because, while the hook length formula always returns an integer, if we didn't evaluate the entire expression at once (as is impossible for a computer), the divisons produced _very_ small numbers. These get cancelled out by multiplcation by equally large numbers later, but if the division results in a number small enough to get rounded to 0, it breaks. The smallest number I saw while debugging was 5e-324 (I read somewhere that Python floats are 64-bit), and after the next division, it got rounded to zero. What happened is that the first division divided by, essentially, k!. It then multiplied by a few small numbers (only 1 or 2 numbers, each less than 10). Then divided by something on the order of (k-1)!, then multiplied by a few more small numbers (maybe 3 or 4 this time, all less than 15). Eventually, we were dividing by "small" factorials, and multiplying by many more numbers, so we ended up multiplying by something close to (but smaller than) k!, while only dividing by numbers less than ~1000. Mathematically, these perfectly canceled out to give the desired count. In code, however, all of the heavy-hitting divisions happening first caused the float to round to zero before the large multiplications could save it. 
  
  To fix this, I went back to using the "unsimplified" version of my general hook lenght formula. This formula has many more factorials, but this fixes the above problem by multiplying by a factorial and dividing by a factorial on every iteration. We now hit the other end of the floating point limit, but not until much later. If we fix _k_=2, this doesn't happen until _n_=170. If we fix _k_=_n_, I'm not sure when we hit the limit; I let the code run for about an hour and was only able to get up to _k_=_n_=55 before I stopped the program (I had other things to do). The value returned here was #, though the numbers obtained during the calculation were likely much larger. Not large enough to hit the float limit, though.  

Contrary to how I usually code, this project has many code comments that describe each step of the process.
